import type { ActionResponse } from "./action";
import type { BaseActionsMap } from "./actionBus";
import type { ErrorListenerSignature, ErrorResponse, KeyOf } from "./lib/types";
export type { ActionResponse, BaseActionsMap, ErrorListenerSignature, ErrorResponse, };
export declare function createActionMap<M extends BaseActionsMap>(actions: M, onAnyError?: ErrorListenerSignature<any[]> | ErrorListenerSignature<any[]>[]): { [key in KeyOf<M>]: {
    readonly invoke: (...args: Parameters<M[key]>) => Promise<ActionResponse<Awaited<ReturnType<M[key]>>, Parameters<M[key]>>>;
    readonly addListener: (handler: import("./action").ListenerSignature<M[key]>, listenerOptions?: import("./event").ListenerOptions) => void;
    readonly on: (handler: import("./action").ListenerSignature<M[key]>, listenerOptions?: import("./event").ListenerOptions) => void;
    readonly subscribe: (handler: import("./action").ListenerSignature<M[key]>, listenerOptions?: import("./event").ListenerOptions) => void;
    readonly listen: (handler: import("./action").ListenerSignature<M[key]>, listenerOptions?: import("./event").ListenerOptions) => void;
    readonly removeAllListeners: (tag?: string) => void;
    readonly removeListener: (handler: import("./action").ListenerSignature<M[key]>, context?: object | null, tag?: string | null) => boolean;
    readonly un: (handler: import("./action").ListenerSignature<M[key]>, context?: object | null, tag?: string | null) => boolean;
    readonly off: (handler: import("./action").ListenerSignature<M[key]>, context?: object | null, tag?: string | null) => boolean;
    readonly remove: (handler: import("./action").ListenerSignature<M[key]>, context?: object | null, tag?: string | null) => boolean;
    readonly unsubscribe: (handler: import("./action").ListenerSignature<M[key]>, context?: object | null, tag?: string | null) => boolean;
    readonly promise: (options?: import("./event").ListenerOptions) => Promise<[arg: ActionResponse<Awaited<ReturnType<M[key]>>, Parameters<M[key]>>]>;
    readonly addErrorListener: (handler: ErrorListenerSignature<Parameters<M[key]>>, listenerOptions?: import("./event").ListenerOptions) => void;
    readonly removeAllErrorListeners: (tag?: string) => void;
    readonly removeErrorListener: (handler: ErrorListenerSignature<Parameters<M[key]>>, context?: object | null, tag?: string | null) => boolean;
    readonly errorPromise: (options?: import("./event").ListenerOptions) => Promise<[errorResponse: ErrorResponse<Parameters<M[key]>>]>;
    readonly addBeforeActionListener: (handler: import("./action").BeforeActionSignature<M[key]>, listenerOptions?: import("./event").ListenerOptions) => void;
    readonly removeAllBeforeActionListeners: (tag?: string) => void;
    readonly removeBeforeActionListener: (handler: import("./action").BeforeActionSignature<M[key]>, context?: object | null, tag?: string | null) => boolean;
    readonly beforeActionPromise: (options?: import("./event").ListenerOptions) => Promise<Parameters<M[key]>>;
    __type: import("./action").ActionDefinitionHelper<M[key]>;
}; };
